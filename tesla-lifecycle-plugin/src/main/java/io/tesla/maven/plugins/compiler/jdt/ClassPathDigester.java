package io.tesla.maven.plugins.compiler.jdt;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.util.Collection;
import java.util.Enumeration;
import java.util.Map;
import java.util.StringTokenizer;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;

import org.codehaus.plexus.util.Base64;
import org.codehaus.plexus.util.DirectoryScanner;
import org.eclipse.jdt.core.compiler.CharOperation;
import org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader;
import org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException;

import com.google.common.base.Charsets;
import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.ImmutableListMultimap;
import com.google.common.collect.ImmutableMultimap;
import com.google.common.collect.Multimap;

public class ClassPathDigester {

  public static final String TYPE_INDEX_LOCATION = "META-INF/incremental-jdt/types.index";

  private final ClassFileDigester digester = new ClassFileDigester();

  public ClassPathDigester() {}

  public void writeIndex(File outputDirectory, Multimap<String, byte[]> index) throws IOException {
    File indexFile = new File(outputDirectory, TYPE_INDEX_LOCATION);
    indexFile.getParentFile().mkdirs();
    OutputStream os = new FileOutputStream(indexFile);
    try {
      writeTypeIndex(os, index);
    } finally {
      os.close();
    }
  }

  public Multimap<String, byte[]> readIndex(File resource) throws IOException {
    if (resource.isFile()) {
      return getJarTypeDigest(resource);
    } else if (resource.isDirectory()) {
      return getDirectorTypeDigest(resource);
    }
    return ImmutableListMultimap.of();
  }

  private Multimap<String, byte[]> getJarTypeDigest(File file) throws IOException {
    ZipFile zip = new ZipFile(file);
    try {
      ZipEntry index = zip.getEntry(TYPE_INDEX_LOCATION);
      if (index != null) {
        InputStream is = zip.getInputStream(index);
        try {
          return readTypeIndex(is);
        } finally {
          is.close();
        }
      }
      Multimap<String, byte[]> result = ArrayListMultimap.create();
      Enumeration<? extends ZipEntry> entries = zip.entries();
      while (entries.hasMoreElements()) {
        ZipEntry entry = entries.nextElement();
        String fileName = entry.getName();
        if (entry.getName().endsWith(".class")) {
          InputStream is = zip.getInputStream(entry);
          try {
            digest(result, is, fileName);
          } finally {
            is.close();
          }
        }
      }
      return result;
    } finally {
      zip.close();
    }
  }

  private void digest(Multimap<String, byte[]> result, InputStream inputStream, String fileName)
      throws IOException {
    try {
      ClassFileReader reader = ClassFileReader.read(inputStream, fileName);
      byte[] hash = digestClass(reader);
      if (hash != null) {
        result.put(new String(CharOperation.replaceOnCopy(reader.getName(), '/', '.')), hash);
      }
    } catch (ClassFormatException e) {
      // as far as jdt compiler is concerned, the class is not present
    }
  }

  public byte[] digestClass(ClassFileReader reader) {
    // XXX add unit tests for local, anonymous and structural changes
    if (!reader.isLocal() && !reader.isAnonymous()) {
      // note on using smaller number of bytes per hash
      // for ~20k classes in the index
      // using full 20 byte hash results in index size ~1.6M txt ~762k zip
      // using 10 byte hash results in index size ~1.3M txt ~535k zip
      // zip of the ~20k classes is ~52M, so index size is insignificant (1.5%)
      // reduced hash size does not noticeably reduce index size
      return digester.digest(reader);
    }
    return null;
  }

  private Multimap<String, byte[]> getDirectorTypeDigest(File dir) throws IOException {
    File index = new File(dir, TYPE_INDEX_LOCATION);
    if (index.isFile()) {
      // XXX index gets out of sync when classes are generated by eclipse
      // need to maintain index in eclipse or at least remove it during workspace build

      // on fairly slow 13-inch, Mid 2012 macbook air (yes, I did say "macbook air")
      // indexing ~23k class files takes ~9.5 seconds with empty filesystem cache
      // indexing the same ~23k class files takes ~3.5 seconds with warm filesystem cache
      // checking timestapt&size of the same 23k class takes ~1second

      // TODO based on the above, read the index first, then index classes newer than the index

      InputStream is = new FileInputStream(index);
      try {
        return readTypeIndex(is);
      } finally {
        is.close();
      }
    }
    Multimap<String, byte[]> result = ArrayListMultimap.create();
    DirectoryScanner scanner = new DirectoryScanner();
    scanner.setBasedir(dir);
    scanner.setIncludes(new String[] {"**/*.class"});
    scanner.scan();
    for (String rpath : scanner.getIncludedFiles()) {
      InputStream is = new FileInputStream(new File(dir, rpath));
      try {
        digest(result, is, rpath);
      } finally {
        is.close();
      }
    }
    return result;
  }

  // index file format
  // one record per line, lines are terminated with '\n'
  // each record is a sequence of values, values are separate by ' ' (space)
  // first value is record type
  // 'T' record: type hash+, where hash is Base64 encoded class file digest

  private Multimap<String, byte[]> readTypeIndex(InputStream is) throws IOException {
    Multimap<String, byte[]> result = ArrayListMultimap.create();
    BufferedReader r = new BufferedReader(new InputStreamReader(is, Charsets.UTF_8));
    String str;
    while ((str = r.readLine()) != null) {
      final StringTokenizer st = new StringTokenizer(str, " ");
      if (!st.hasMoreTokens() || !"T".equals(st.nextToken())) {
        return ImmutableMultimap.of();
      }
      if (!st.hasMoreTokens()) {
        return ImmutableMultimap.of();
      }
      final String type = st.nextToken();
      while (st.hasMoreTokens()) {
        result.put(type, Base64.decodeBase64(st.nextToken().getBytes(Charsets.UTF_8)));
      }
    }
    return result;
  }

  private void writeTypeIndex(OutputStream os, Multimap<String, byte[]> index) throws IOException {
    for (Map.Entry<String, Collection<byte[]>> entry : index.asMap().entrySet()) {
      os.write("T".getBytes(Charsets.UTF_8));
      os.write(' ');
      os.write(entry.getKey().getBytes(Charsets.UTF_8));
      for (byte[] hash : entry.getValue()) {
        os.write(' ');
        os.write(Base64.encodeBase64(hash, false));
      }
      os.write('\n');
    }
  }

}
